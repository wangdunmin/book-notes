本章将会探索与数字相关的类型，例如集合和布尔型

# Python的数字类型

在Python中，数字并不是一个真正的对象类型，而是一组类似类型的分类；它不仅支持通常的数字类型(整数和浮点数)，而且能过通过常量去直接创建数字以及处理数字的表达式；它还为高级的工作提供了高级数字编程支持和对象。

Python数字类型的完整工具包括：

* 整数和浮点数
* 复数
* 固定精度的十进制数
* 有理分数
* 集合
* 布尔类型
* 无穷的整数精度
* 各种数字内置函数和模块

我们从基本的数字开始，然后介绍上面列表中的其它工具；首先下面俩个小节让我们看看如何在脚本中编写和处理数字

## 数字常量

### 整数

整数的常量表示为一个十进制数字的字符串；它可以表示正整数和负整数

```python
>>> 1234,-24,0, 99999999999999999
(1234,-24,0, 99999999999999999)
```

#### 一般整数和长整数

Python中整数分为两种，第一种是**一般整数**为32位，占4个字节；第二种是**长整数**，无穷精度

* Python2.6中的一般整数和长整数

    在Python2.6中，**一般整数**和**长整数**为两种整数类型，我们可以以上面的语法定义一般整数；在定义长整数时，我们需要在整数末尾加上字母'l'或者'L'表示长(Long)整数;不过当整数的值超过32位时，它会自动将整数转换为长整数，不需要我们去输入'l/L'后缀，**一般情况下当整数不能被自动转换为长整数而我们确实需要长整数时我们才需要去添加后缀**，当需要额外的精度时Python会自动转换为长整数。

* Python3.0中的一般整数和长整数

    在Python3.0中，将一般整数和长整数类型合二为一了，它自动的支持长整数的无穷精度，我们不需要去指定数字后缀，相应的，在显示时也不会显示这个后缀

### 浮点数

浮点数可以是一个带有小数点的数，或者加上一个科学计数表示e/E，当浮点数在表达式中时，将启用浮点数的运算法则，浮点数的精度与构建Python解释器的C编译器所给定的双精度的精度一样

```python
>>> 1.23
1.23
>>> 1.
1.0
>>> 4E20
4e+20
>>> 4e-20
4e-20
>>> 3.14e3
3140.0
```


### 十六进制

十六进制常量以0x或0X开头，后面接十六进制的数字0-9，a-f/A-F

```python
>>> 0XA
10
>>> 0xF
15
```

和以下将要介绍的八进制，二进制一样，常量语法实际产生的是一个整数对象；我们可以通过hex内置函数把一个整数转换为十六进制表示的字符串

```python
>>> hex(15)
'0xf'
```

### 八进制

八进制常量以0o或0O开头，后面接八进制的数字0-7；在Python2.6及更早版本中，八进制常量也可以是以0开头，但是这太容易和十进制数混淆了。

```python
>>> 0o72
58
```

我们可以通过oct内置函数把一个整数转换为十六进制表示的字符串

```python
>>> oct(8)
'0o10'
```

### 二进制

二进制常量以0b或0B开头，后面接二进制的数字0-1

```python
>>> 0b111
7
```
我们可以通过bin内置函数把一个整数转换为十六进制表示的字符串

```python
>>> bin(1000)
'0b1111101000'
```

> 我们也可以通过int(str,base)内置函数将一个字符换转换为一个整数,其中base为进制数，默认为10
> ```python
> >>> int('0b1111101000',2)
> 1000
>```
> 

### 复数

复数常量为**实部+虚部**，其中，虚部以j或J结尾，实部可以省略；内部看来，复数是通过一对浮点数表示的，但是在操作复数时，它是通过复数的运算法则去进行的。也可以使用内置函数complex(real,imag)来创建一个复数

```python
>>> 1+2j
(1+2j)
>>> 2j             # 实部可以省略
2j
>>> complex(1,2)
(1+2j)
>>> complex(2)     # 实部不可以省略
(2+0j)
```

### 其它的数字类型

还有一些数字类型我们会在本章后面看到，它们有的通过导入模板中的函数来创建，有的则拥有自己的常量语法

## 内置数学工具和扩展

Python还提供了一系列处理数字对象的工具，有**表达式操作符**，**内置数学函数**(pow,abs,round等)和**公共模块**(random,math等)，除此之外，数字还有很多**特定于类型的方法和属性**，例如浮点数的as_integer_ratio方法(对分数数字类型很有用)，数字的is_integer(数字是否是整数)方法和在Python3.1中的bit_length方法(给出表示对象的值所必需的位数)

> 集合既像一些集合一样也像一些数字一样；它支持这两者的方法和表达式

表达式操作符是**大多数**数字类型最基本的工具；我们接下来介绍它

### Python表达式操作符

表达式是处理数字最基本的工具，下表列举了Python中所有的操作符表达式，下表中的表达式并不都具备数值特性

|操作符|描述|版本差异|
|:---|:---|---|
|yield x|生成器函数发送协议；必须出现在函数体内|Python2.5后可用|
|lambda args : expression|生成匿名/lambda函数|
|x if y else z|三元选择表达式；表示如果y为true则返回x的值，否则返回z|Python2.5后可用|
|x or y |逻辑或，短路操作：只有x为false时才会计算y|
|x and y|逻辑与，短路操作：只有x为true时才会计算y|
|not x|逻辑非|
|x in  y, x not in y|成员关系(用于可迭代对象，集合)|
|x is y, x is not y|对象实体测试|
|x < y,x <= y, x > y,x >= y,x == y,x != y|大小比较，集合子集和超集值相等性操作符|Python2.6中，值不相等也可以写成x<>y|
|x \| y |位或，集合并集|
|x ^ y| 位异或，集合对称差|
|x & y| 位与，集合交集|
|x << y, x >> y|左移或右移y位|
|x + y, x - y|加法/合并集合；减法/集合差集|
|x * y, x % y, x / y, x // y|乘法/重复；余数/格式化；除法：真除法或floor除法|x / y : Python3.0中执行真正的除法(保留余数)，Python3.6执行传统除法(截取为整数)|
|-x, +x |一元减法，识别|
|~x|按位求补(取反)|
|x ** y|幂运算|
|x[i]|索引(序列，映射和其它)，点号取属性运算，函数调用|
|x[i:j:k]|分片|
|x(...)|调用(函数，方法，类及其它可调用的)|
|a.attr|属性引用|
|(...)|元组，表达式，生成器表达式|
|[...]|列表，列表解析|
|{...}|字典，集合，字典和集合解析|Python3.0中可以表示集合常量，集合字典的解析|

* Python2.x中，混合类型比较(不同类型比较)是允许的；在Python3.0中非数字的混合类型的大小比较是不允许的，会引发异常

* Python3.0中，字典的大小比较也不再支持(支持相等性比较)；若要比较字典的大小，可以通过函数sort(dict.items())

#### 混合操作所遵循的操作符优先级

我们可以把多个操作符组合成一个表达式；那么Python是如何确定首先执行哪个操作符呢？这就是操作符的优先级，以上面的表格为基准：

* 越靠后的行优先级越高
* 位于同一行的操作符在组合时通常是从左到右组合(幂运算是从右到左)

例如a + b \* c：它会先求出b \* c的结果，因为它的优先级较高

#### 括号分组的子表达式

用括号括起来的表达式优先级总是最高的，Python总会先执行括号中的表达式；在大型表达式中使用括号分组是一个不错的注意，它不仅强制按照你想要的顺序执行，还提高了程序可读性

#### 混合类型自动升级

表达式除了可以混合操作符外，也可以混合数字的类型，当出现不同的数字类型时，它根据类型的复杂度，将简单的类型转换为复杂的类型，数字的复杂度如下
```
整型 < 浮点型 < 复数
```
我们也可以在表达式中使用内置函数int，float进行强制类型转化；但是这通常是没有必要的，Python会自动进行类型转换

最后要记住，在Python3.0中，不支持其它类型之间的转换，例如数字和字符串；如果你有这样的需求时，可以通过手动转换其中的某个类型去实现。

#### 预习：运算符重载

我们已经发现了，当一个操作符用于不同的类型时，它的意义是不同的，这成为操作符的重载，而这一特性被称为多态。对于某些操作符(比如+)，Python已经为内置的类型进行了重载，我们也可以对我们扩展的或者自定义的类型进行重载

## 在实际应用中的数字

### 变量和基本的表达式

变量

* 变量在它第一次赋值时创建 
* 变量在表达式中时会被替换为它们的值
* 变量在表达式中使用时必须已经赋值
* 变量不需要再一开始时进行声明

关于结果输出
* 命令行模式默认将结果输出为一个元组

### 数字显示的格式

当不用print进行输出时，由于硬件对浮点数的不足，它会显示出奇怪的值，此时我们可以通过print将结果输出出来，或者使用字符串格式化进行输出

> str 和repr 显示格式
> 
> 这俩个函数都会把任意对象转换成它们的字符串表示；**str**相当于交互模式中使用print，它一般将对象转换为对用户友好的格式，除此之外，它还是字符串数据类型的名字，对于字符串类型有额外的用处；**repr**相当于交互模式中的回显，它将对象转换的结果就好像是它们的代码；str用于一般用途，repr用于额外细节

### 比较：一般的和连续的


比较操作比较操作数的**相对大小**，返回一个布尔类型的结果。

连续的比较语句可以看做是多个一般的比较语句使用and连接，虽然结果一样，但连续比较更快速，因为它会减少中间变量的值引用。

```
>>> 1 < 2 < 3
>>> True
>>> 1 < 2 and 2 < 3
```

注意，连续比较并不是将前面的比较结果和后面进行比较

### 除法：传统除法，Floor除法和真除法

Python中有三种类型的除法，两种不同的除法操作符，其中一种操作符在Python3.0中有了变化

* X / Y

**传统除法**和**真除法**：Python2.6及之前的版本，称为传统除法，当操作数为整数时会对结果省去小数部分使其为一个整数，当操作数中有浮点数时会保留小数部分执行除法操作；Python3.0中称为真除法，不管是小数还是整数都会保留小数部分

* X // Y

**Floor除法**：Python2.2中新增的操作；它不考虑操作数的类型，总会省略掉小数部分，针对结果向下取整；当操作数都为整数时，结果为一个向下取整的整数，当操作数中包含小数时，结果为一个向下取整的小数

添加真除法是为了解决传统除法的结果依赖于操作数类型(在Python这种动态类型语言上结果很难预料)这一现象，Python中，/为真除法，//为Floor除法

#### 支持两个Python版本

如果你的程序依赖于阶段整数除法，那么就是用//；如果你的程序对于整数需要浮点数结果，那么在Python 2.6中可以使用float函数将数值转换为浮点数；我们也可以在Python2.6中执行from __future__ import division 打开Python3.0的/。

#### Floor除法VS截断除法

对于//，更准确的，它是Floor除法而不是截断除法，对于正数，俩者的结果都一样，对于正数它真正执行的是Floor向下取整，而不是截取

```python
>>> 9 // 4
2
>>> 9 // -4
-3
```
Python 2.6中针对整数的传统除法其结果也是Floor的

如果你确实想使用截断，那么可以借助math模块的trunc，注意在Python2.6的传统除法中，你需要先将传统除法转换为真除法

#### 为什么截断很重要

很多程序处理会去依赖截断的结果

### 整数精度

Python2.6中，有一般整数和长整型(末尾为l/L)俩个整数类型，在数值太大了无法存储到一般整数时会自动将数字转换为这个类型，Python3.0只有整数一种类型，它存储一般整数和长整数；长整数的数学运算要比正常额整数运算更慢

### 复数

复数是个不同的核心对象类型，它可以通过标准的cmath模块(复数版的math模块)中的工具进行处理，复数通常在面向工程的程序中扮演重要的角色

### 十六进制，八进制和二进制记数

我们前面已经提到过，十六进制，八进制，二进制只是在实际存储时实际存储的是十进制数，我们可以使用hex,oct,bin函数将十进制数转换为对应进制的字符串表示，也可以用int函数将字符串转换为十进制数

eval函数也会将进制字符串转换成十进制；它实际是将一段字符当做Python程序去执行，由于有解释的过程，所以它的速度相对会慢一些

```python
>>> eval('64'),eval('0o100'),eval('0x40'),eval('0b1000000')
(64, 64, 64, 64)
>>>
```

除此之外，字符串格式化也可以将整数格式化为进制字符形式

```python
>>> '{0:o},{1:x},{2:b}'.format(64,64,64)
'100,40,1000000'
>>> '%o,%x,%X'%(64,255,255)
'100,ff,FF'
```

针对进制数有两个注意点

* Python2.6中，八进制以数字0开始；在Python2.6中，应该尽量使用0o/0O
* 这些常量会产生任意长度的整数
```python
>>> x = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff
>>> x
105312291668557186697918027683670432318895095400549111254310977535
>>> oct(x)
'0o777777777777777777777777777777777777777777777777777777777777777777777777'
>>> bin(x)
'0b111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'
```

### 位操作

Python除了支持基本的数学运算外，也支持对二进制数的位运算

```python
>>> x = 1
>>> bin(x)
'0b1'
>>> 1 << 2  # 左移两位 0001 左移两位 --> 0100； 同理：>>代表右移
4
>>> 1 | 2   # 按位或   0001 | 0010 --> 0011 
3
>>> 1 & 2   # 按位与   0001 | 0010 --> 0000
0
>>> 1 ^ 1   # 位异或   0001 | 0010 --> 0000  ;俩者位上的值相同时为0，不同时为1
0
>>> 1 | 0b10 # 不仅可以使用整数，也可以使用进制数 
3
>>> 1 | 0x2
3
>>> 1 | 0o2
3
>>>
```

我们在Python这样的高级语言中，是不需要直接与位打交道的，除非Python必须与二进制数据打交道。

> Python3.1中，我们可以通过bit_length方法查询出二进制表示一个数字所需要的位数，我们也可以通过len内置函数求出一个二进制字符串的长度然后前去前缀的数量2得到这样的结果,但这样通常效率会很低
>
> ```python
> >>> (1).bit_length()
> 1
> >>> (2).bit_length()
> 2
> >>> (3).bit_length()
> 2
> >>> len(bin(1))-2
> 1
> ```
>