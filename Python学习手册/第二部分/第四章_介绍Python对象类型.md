从非正式的角度来说：在Python中，我们使用一些东西做事情；这里**事情**指的就是像'+'一样的操作形式，而**东西**指的就是我们操作的**对象**。

从更正式的角度来说：在Python中，数据已对象的形式出现，不管它是内置的还是自定义的对象；对象是内存的一部分，包含数值和操作的集合

Python程序可以分解为模块，语句，表达式，对象；它们的关系如下：
* **程序**由**模块**组成
* **模块**包含**语句**
* **语句**包含**表达式**
* **表达式**操作(建立并处理)**对象**

这就是我们在这里学习对象的原因

# 为什么使用内置类型

在C/C++这样的底层语言中，需要我们耗费大量的精力去设计结构体/对象去表现应用层领域的组件并操作(部署内存结构，管理内存分配，实现搜索和读取例程等)它们。这些工作听起来非常乏味，而且容易出错，并且往往我们不能将精力放在程序的业务实现上，常常会背离程序的真正目标。

Python中，这些令人头疼的问题将不复存在，它提供了**对象类型**作为语言的组成部分，使我们不必把大量的精力浪费在操作数据底层上。当然你可以定义自己的对象类型，但是这应该只是在内置类型无法解决你的问题问题时，否则你应该总是使用内置对象类型，原因如下：

* **内置对象使程序更容易编写**，对于简单的任务，内置对象就够了；它提供了很多强大的工具，比如集合(列表)和搜索表(字典)，后面还会介绍很多，我们可以直接使用它们

* **内置对象是扩展组件的基类**，对于较为复杂的任务，我们也许需要自己去实现自己的对象，但是这些对象往往都建立在内置对象的基础之上；比如堆栈数据结构可实现为管理和定制内置列表的类。

* **内置对象往往比定制的对象有更好的效率**，内置对象往往优化成了用C实现的数据结构算法，它们有更好的执行效率。自己实现的对象往往很难达到这种性能水平

* **内置对象是语言的标准的一部分**，由于内置类型是标准的，它们一般在不同的平台下都是一致的；自定义的往往在不同的环境下都有所不同

> LISP语言是依靠内置工具的语言，像C++这种的是依靠程序员去提供自己实现的语言，Python结合俩两类语言的优点，在内置了一些强大的工具的同时，也提供了自实现对象的能力

一句话总结就是：与我们从零开始所创建的工具相比，内置类型不仅让编程变得更简单，而且它们也更强大和高效；无论你是否实现新的对象类型，内置对象都构成了每一个Python程序的核心部分。

# Python的核心数据类型

下表列出了Python的内置对象类型和对象对应的**常量**

> 常量又称常数，它是指**生成对象的表达式**，而不是指对象不可变

|对象类型|例子 常量/创建|
|---|---|
|数字|1234， 3.1415,3+4j， Decimal， Fraction|
|字符串|'spam'， "guido's"， b'a\xolc'|
|列表|[1,[2,'three'],4]|
|字典|{'food':'spam','taste':'yum'}|
|元组|(1,'spam',4,'U')|
|文件|myfile=open('eggs','r')|
|集合|set('abc')， {'a','b','c'}|
|其它类型|类型， None， 布尔型|
|编程单元类型|函数， 模块， 类|
|与实现相关的类型|编译的代码堆栈跟踪|

上表所列的内容并不完整，我们知道在Python中它所处理的每样东西都是一种对象；我们可能在进行文本模式匹配时，创建了模式对象；在进行网络编程时，使用了套接字对象。还有一些其它的对象都是通过导入或使用模板来建立的，它们都有各自的行为。

在Python中，像函数，模块，类这样的编程单元也是对象，它们可以在脚本间自由的传递，存储在其它对象中等。Python还提供了一组与实现相关的类型，如编译过的代码对象，它往往关系到工具生成器而不是程序开发者，后面会详细的讲解这些。

在上表列出的对象类型我们通常称为**核心数据类型**，它们都有一些特定语法可以高效的生成它们。如：
```
>>> 'spam'
```
当你运行这个常量表达式时，Python为你返回了一个字符串类型对象；类似的，你可以使用其它常量表达式创建特定的对象

在Python中，没有类型声明，运行的表达式的语法决定它的类型，那些对象生成表达式就是这些类型起源的地方；一旦你创建了一个对象，那么它就和该对象对应的操作集合绑定了，比如当你创建字符串类型的对象时，你就可以针对这个对象进行字符串相关的操作

> Python是动态类型的(它会主动跟踪对象的实际类型)同时也是强类型(它只能进行适合该类型的操作)的

在功能上，表中列出的数据类型可能比你习惯使用的类型更常用也更强大，我们会在后面的学习中感受到这点

下面让我们快速浏览一下这些核心类型，后面我们会对每一种类型进行深入

# 数字

Python的数字类型包括整数和浮点数，除此之外还有其它的一些少见的类型如:有虚部的复数，固定精度的十进制数，带分子和分母的有理分数,集合等

Python的数字支持一般的数学运算，例如加号(+)代表加法，星号(*)表示乘法，双星号(**)表示乘方

``` python
>>> 123+222
345
>>> 1.5*4
6.0
>>> 2**100
1267650600228229401496703205376
```

注意最后一个结果，在Python3.0中，当数值较大时，它会自动提供额外的精度；在Python2.6中，它提供了长整型去处理这类大数值。

**有俩种打印对象的方式，一种对象的代码形式repr，一种是用户友好形式str**；当我们使用类时，这俩种的区别会展示出来。比如当我们在打印数字时，repr显示数字的全精度，而str显示对用户友好的形式

```python
>>> 3.1415 * 2
6.2830000000000004
>>> print(3.1415 * 2)
6.283
```
上面第一种是全精度形式。注意在实际测试中，第一行代码和第二行代码打印结果相同，应该是Python修复了精度的bug或者说计算这个数值时不存在精度的问题

除了表达式以外，Python还提供了**math**数学模块工具包,我们可以导入以使用它们

Python还包括了一些极为少见的数字对象，如复数，固定精度十进制数，有理数，集合和布尔值，第三方开源扩展领域还包括了其它更高级的如矩阵和向量。

# 字符串

字符串是用来记录文本信息的。严格意义上讲，字符串是的单个字符的字符串的序列。序列是一个包含其它对象的有序集合；序列中的元素包含了一个从左到右的顺序-序列中的元素根据它们的相对位置进行存储和读取，字符串是我们提到的第一个序列，其它序列还有列表和元组。

## 序列的操作

-- **所有序列共有的操作**

作为序列，字符串支持位置索引的相关操作；索引是按照从最前面的偏移量进行编码的，第一个的偏移量为0，第二个为1，以此类推。比如

```python
>>> S = 'Spam'
>>> len(S)
4
>>> S[0]
'S'
>>> S[1]
'p'
```

> len函数是Python中的内置函数，它将得到对象的长度

> 由S = 'Spam' 引申的变量赋值
>
>1. Python中的变量不需要提前声明，当给它赋值时就创建了它
>2. 当变量出现在一个表达式中时，就会用其值替换之前的值
>3. 在使用变量前必须对其赋值
> 
> 详细的变量规则将会在第六章给出

除此之外我们还可以使用反向索引；正向索引从左到右，反向索引从右到左

```
>>> S[-1]
'm'
```

一般来说，负索引会简单的与字符串的长度相加得出最终索引，如字符串长度为4时，当你取-1时，位置索引相加得3，那么它取得的就是第三个索引位置的值。如下，它们的结果是相同的

```python
>>> S[-1]
'm'
>>> S[len(S)-1]
'm'
```

在方括号中，Python支持我们使用数字常量，变量和表达式

除了位置索引，Python也支持分片操作；这使得我们可以一次性取得一个分片区域；它的语法为X[I:J]，表示**取出X中从偏移量I开始，直到J结束但不包括J**，结果将会返回一个**新的对象**，其中：**I默认为0，J默认为分片序列的长度**，并且它支持负索引，负索引的索引规则和上面相同。以下是分片的例子：

```python
>>> S[1:]  # J默认为S的长度
'pam'
>>> S      # S原序列并没有发生改变，分片操作会返回一个新的对象
'Spam'
>>> S[0:3]
'Spa'
>>> S[:3]   #I默认为0
'Spa'
>>> S[:-1]  #支持负索引
'Spa'
>>> S[:]   # 作用类似于拷贝一个新的序列对象
'Spam'
```

除此之外，序列还支持使用加号进行**合并**，或者**重复**

合并的语法为 var1 + var 2；它们会产生一个新的序列

重复的语法为 var1 * count；它会将var1重复count次

如下：

```python
>>> S
'Spam'
>>> S + 'xyz' # 合并的值可以是变量或常量或其它表达式
'Spamxyz'
>>> S * 3     # 将变量S的值重复三次
'SpamSpamSpam'
```

> 加号(+)对于不同的对象有不同的含义，这就是Python中的**多态**体现；它在这里是合并的意思，在数字中视为加法。简而言之，一个操作的意义取决于它所操作的对象。这种特性给Python的代码带来了极大的简洁性和灵活性。只要它们支持一种兼容的接口(就像这里的+)，Python的操作就可以自动的适应不同的对象。

## 不可变性

在之前的例子中，我们没有通过任何操作对原始的数据进行更改，修改的结果都作用在返回的对象中；这是因为在Python中，字符串具有**不可变性**，它在创建后就不可改变。我们不能通过对某一索引位置复制而改变它。但是我们可以通过新建一个字符串对象然后将值赋给原有变量的方式去改变变量的值，但是这仅仅是改变变量的值，它不会改变变量之前的字符量。如下：

```python
>>> S[0] = 'a'  # 当我们通过位置索引去复制时会发生错误
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> S = 'a' + S[1:]  # 我们可以通过对字符变量重新复制的方式改变它
>>> S
'apam'
```

> 在Python中，每一个对象都可以分为不可变性或可变性，在核心类型中，**数字**，**字符串**和**元组**是不可变的；**列表**和**字段**是可变的。

不可变性可以用来保证在程序中保持一个对象固定不变

## 类型特定的方法

-- 字符串类型的方法

字符串还有其独有的操作，它们作为方法存在

|字符串方法|含义|示例|结果|
|---|---|---|---|
|find|子字符串查找操作,它返回子字符串的位置偏移量，当没有找到时，返回-1|'Spam'.find(pa)|1|
|replace|替换子字符串|'Spam'.replace('pa','XYZ')|SXYZm|
|split|分割字符串|'a,b,c,d'.split(',')|['a','b','c','d']|
|upper|将小写字符转换为大写字母|'xY'.upper()|XY|
|isalpha|是否是字母|'a'.isalpha()|True|
|isdigit|是否是数字|'a'.isdigit()|Flase|
|rstrip|去除字符收尾空格字符|'aaa,bbb\n'.rstrip()|aaa,bbb|

注意虽然字符串方法名存在改变的含义，但是由于字符串是**不可变的**，所以它常常是返回一个新的字符串值，原来的字符串并不发生改变

除了这些基本的方法之外，字符串还支持一种叫做**格式化**的高级替换操作；它可以使用表达式的形式(最初的)或作为一个字符串方法(Python2.6和3.0新引入的)调用。

```python
>>> '%s 是 %s' % ('你','我的')
'你 是 我的'
>>> '{0} 也是 {1}'.format('你','我的')
'你 也是 我的'
```

> 通常来说；多种类型通用的操作都是以内置函数(len())或表达(S[0])式的形式出现，而类型特定的操作一般都是以方法调用的形式出现('a'.upper())。记住这些可以让我们很轻松的从Python世界中找到并使用我们需要的工具；下面会介绍一些技巧

## 寻求帮助

虽然我们在上面介绍了字符串的一些方法，但是对于字符串类型来说，这只是其中的一部分，我们可以通过以下的步骤去获取其它的方法列表和使用方式

1. 第一步，使用dir内置函数列出**对象**的属性，由于方法也是属性的一部分，所以它们也会被列出

    ```python
    >>> dir('a')
    ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '_
    _eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs
    __', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__'
    , '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',
    '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__'
    , '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'e
    ncode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isal
    num', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', '
    isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lo
    wer', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust',
    'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
    'swapcase', 'title', 'translate', 'upper', 'zfill']
    ```

    > 在后面我们会给出，我们可以通过自定义以下划线开头结尾的属性去定制自己的类型和操作
2. 第二步，使用help内置函数，获取对应属性的详细介绍

    ```python
    >>> help('a'.isupper)
    Help on built-in function isupper:

    isupper() method of builtins.str instance
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.

    ```

    help方法也支持传入一个对象，此时它将会返回对象所有方法的详细信息

    > Python中与help类似的有一个PyDoc工具，他可以从对象中提取文档，并将结果生成HTML格式

## 编写字符串的其它方法

* 反斜线转义序列表示的特殊字符

```python
>>> len('a\nB\tC') # \n代表换行 \t代表空格 它们每个代表一个字符
5
>>> ord('\n')      # \n 在ASCII中表示为10
10
>>> len('A\0B\0C') # \0 二进制0字节，不终止字符串
5
```

* 三引号包含多行字符；字符串可以包括在单引号和双引号中，它们的意义相同

```python
>>> a = '''
... a
... ccc
... '''
>>> a
'\na\nccc\n'
```
* 原始字符常量；对字符中的转义字符不做处理，它们通常以'r'开头
```python
>>> a = 'a\na'
>>> print(a)
a
a
>>> a = r'a\na'
>>> print(a)
a\na
```

* Unicode字符串

```python
>>> a = '\u6211'
>>> print(a)
我
```
> Python3.0中，str类型也处理Unicode，bytes类型表示原始字节字符串
> 
> Python2.6中，Unicode是单独的类型，str处理8位字符串和二进制数据 

## 模式匹配

使用模式匹配，我们需要导入**re**模块，然后使用它其中包含的工具方法

```python
>>> import re
>>> match = re.match('Hello[ \t]*(.*)world','Hello    Python world')
>>> match.group(1)
'Python '
>>> match = re.match('/(.*)/(.*)/(.*)','/usr/hoe/tesr')  # 当字符串为usr/hoe/tesr返回的match对象没有相关方法
>>> match.groups()
('usr','hoe','tesr')
```

模式匹配是一个相当高级的文本处理工具，在Python中，还支持更高级的语言处理工具，如**自然语言处理**等