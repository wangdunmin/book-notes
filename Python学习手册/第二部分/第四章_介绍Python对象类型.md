从非正式的角度来说：在Python中，我们使用一些东西做事情；这里**事情**指的就是像'+'一样的操作形式，而**东西**指的就是我们操作的**对象**。

从更正式的角度来说：在Python中，数据已对象的形式出现，不管它是内置的还是自定义的对象；对象是内存的一部分，包含数值和操作的集合

Python程序可以分解为模块，语句，表达式，对象；它们的关系如下：
* **程序**由**模块**组成
* **模块**包含**语句**
* **语句**包含**表达式**
* **表达式**操作(建立并处理)**对象**

这就是我们在这里学习对象的原因

# 为什么使用内置类型

在C/C++这样的底层语言中，需要我们耗费大量的精力去设计结构体/对象去表现应用层领域的组件并操作(部署内存结构，管理内存分配，实现搜索和读取例程等)它们。这些工作听起来非常乏味，而且容易出错，并且往往我们不能将精力放在程序的业务实现上，常常会背离程序的真正目标。

Python中，这些令人头疼的问题将不复存在，它提供了**对象类型**作为语言的组成部分，使我们不必把大量的精力浪费在操作数据底层上。当然你可以定义自己的对象类型，但是这应该只是在内置类型无法解决你的问题问题时，否则你应该总是使用内置对象类型，原因如下：

* **内置对象使程序更容易编写**，对于简单的任务，内置对象就够了；它提供了很多强大的工具，比如集合(列表)和搜索表(字典)，后面还会介绍很多，我们可以直接使用它们

* **内置对象是扩展组件的基类**，对于较为复杂的任务，我们也许需要自己去实现自己的对象，但是这些对象往往都建立在内置对象的基础之上；比如堆栈数据结构可实现为管理和定制内置列表的类。

* **内置对象往往比定制的对象有更好的效率**，内置对象往往优化成了用C实现的数据结构算法，它们有更好的执行效率。自己实现的对象往往很难达到这种性能水平

* **内置对象是语言的标准的一部分**，由于内置类型是标准的，它们一般在不同的平台下都是一致的；自定义的往往在不同的环境下都有所不同

> LISP语言是依靠内置工具的语言，像C++这种的是依靠程序员去提供自己实现的语言，Python结合俩两类语言的优点，在内置了一些强大的工具的同时，也提供了自实现对象的能力

一句话总结就是：与我们从零开始所创建的工具相比，内置类型不仅让编程变得更简单，而且它们也更强大和高效；无论你是否实现新的对象类型，内置对象都构成了每一个Python程序的核心部分。

# Python的核心数据类型

下表列出了Python的内置对象类型和对象对应的**常量**

> 常量又称常数，它是指**生成对象的表达式**，而不是指对象不可变

|对象类型|例子 常量/创建|
|---|---|
|数字|1234， 3.1415,3+4j， Decimal， Fraction|
|字符串|'spam'， "guido's"， b'a\xolc'|
|列表|[1,[2,'three'],4]|
|字典|{'food':'spam','taste':'yum'}|
|元组|(1,'spam',4,'U')|
|文件|myfile=open('eggs','r')|
|集合|set('abc')， {'a','b','c'}|
|其它类型|类型， None， 布尔型|
|编程单元类型|函数， 模块， 类|
|与实现相关的类型|编译的代码堆栈跟踪|

上表所列的内容并不完整，我们知道在Python中它所处理的每样东西都是一种对象；我们可能在进行文本模式匹配时，创建了模式对象；在进行网络编程时，使用了套接字对象。还有一些其它的对象都是通过导入或使用模板来建立的，它们都有各自的行为。

在Python中，像函数，模块，类这样的编程单元也是对象，它们可以在脚本间自由的传递，存储在其它对象中等。Python还提供了一组与实现相关的类型，如编译过的代码对象，它往往关系到工具生成器而不是程序开发者，后面会详细的讲解这些。

在上表列出的对象类型我们通常称为**核心数据类型**，它们都有一些特定语法可以高效的生成它们。如：
```
>>> 'spam'
```
当你运行这个常量表达式时，Python为你返回了一个字符串类型对象；类似的，你可以使用其它常量表达式创建特定的对象

在Python中，没有类型声明，运行的表达式的语法决定它的类型，那些对象生成表达式就是这些类型起源的地方；一旦你创建了一个对象，那么它就和该对象对应的操作集合绑定了，比如当你创建字符串类型的对象时，你就可以针对这个对象进行字符串相关的操作

> Python是动态类型的(它会主动跟踪对象的实际类型)同时也是强类型(它只能进行适合该类型的操作)的

在功能上，表中列出的数据类型可能比你习惯使用的类型更常用也更强大，我们会在后面的学习中感受到这点

下面让我们快速浏览一下这些核心类型，后面我们会对每一种类型进行深入

# 数字

