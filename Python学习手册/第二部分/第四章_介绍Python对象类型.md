从非正式的角度来说：在Python中，我们使用一些东西做事情；这里**事情**指的就是像'+'一样的操作形式，而**东西**指的就是我们操作的**对象**。

从更正式的角度来说：在Python中，数据已对象的形式出现，不管它是内置的还是自定义的对象；对象是内存的一部分，包含数值和操作的集合

Python程序可以分解为模块，语句，表达式，对象；它们的关系如下：
* **程序**由**模块**组成
* **模块**包含**语句**
* **语句**包含**表达式**
* **表达式**操作(建立并处理)**对象**

这就是我们在这里学习对象的原因

# 为什么使用内置类型

在C/C++这样的底层语言中，需要我们耗费大量的精力去设计结构体/对象去表现应用层领域的组件并操作(部署内存结构，管理内存分配，实现搜索和读取例程等)它们。这些工作听起来非常乏味，而且容易出错，并且往往我们不能将精力放在程序的业务实现上，常常会背离程序的真正目标。

Python中，这些令人头疼的问题将不复存在，它提供了**对象类型**作为语言的组成部分，使我们不必把大量的精力浪费在操作数据底层上。当然你可以定义自己的对象类型，但是这应该只是在内置类型无法解决你的问题问题时，否则你应该总是使用内置对象类型，原因如下：

* **内置对象使程序更容易编写**，对于简单的任务，内置对象就够了；它提供了很多强大的工具，比如集合(列表)和搜索表(字典)，后面还会介绍很多，我们可以直接使用它们

* **内置对象是扩展组件的基类**，对于较为复杂的任务，我们也许需要自己去实现自己的对象，但是这些对象往往都建立在内置对象的基础之上；比如堆栈数据结构可实现为管理和定制内置列表的类。

* **内置对象往往比定制的对象有更好的效率**，内置对象往往优化成了用C实现的数据结构算法，它们有更好的执行效率。自己实现的对象往往很难达到这种性能水平

* **内置对象是语言的标准的一部分**，由于内置类型是标准的，它们一般在不同的平台下都是一致的；自定义的往往在不同的环境下都有所不同

> LISP语言是依靠内置工具的语言，像C++这种的是依靠程序员去提供自己实现的语言，Python结合俩两类语言的优点，在内置了一些强大的工具的同时，也提供了自实现对象的能力

一句话总结就是：与我们从零开始所创建的工具相比，内置类型不仅让编程变得更简单，而且它们也更强大和高效；无论你是否实现新的对象类型，内置对象都构成了每一个Python程序的核心部分。

# Python的核心数据类型

下表列出了Python的内置对象类型和对象对应的**常量**

> 常量又称常数，它是指**生成对象的表达式**，而不是指对象不可变

|对象类型|例子 常量/创建|
|---|---|
|数字|1234， 3.1415,3+4j， Decimal， Fraction|
|字符串|'spam'， "guido's"， b'a\xolc'|
|列表|[1,[2,'three'],4]|
|字典|{'food':'spam','taste':'yum'}|
|元组|(1,'spam',4,'U')|
|文件|myfile=open('eggs','r')|
|集合|set('abc')， {'a','b','c'}|
|其它类型|类型， None， 布尔型|
|编程单元类型|函数， 模块， 类|
|与实现相关的类型|编译的代码堆栈跟踪|

上表所列的内容并不完整，我们知道在Python中它所处理的每样东西都是一种对象；我们可能在进行文本模式匹配时，创建了模式对象；在进行网络编程时，使用了套接字对象。还有一些其它的对象都是通过导入或使用模板来建立的，它们都有各自的行为。

在Python中，像函数，模块，类这样的编程单元也是对象，它们可以在脚本间自由的传递，存储在其它对象中等。Python还提供了一组与实现相关的类型，如编译过的代码对象，它往往关系到工具生成器而不是程序开发者，后面会详细的讲解这些。

在上表列出的对象类型我们通常称为**核心数据类型**，它们都有一些特定语法可以高效的生成它们。如：
```
>>> 'spam'
```
当你运行这个常量表达式时，Python为你返回了一个字符串类型对象；类似的，你可以使用其它常量表达式创建特定的对象

在Python中，没有类型声明，运行的表达式的语法决定它的类型，那些对象生成表达式就是这些类型起源的地方；一旦你创建了一个对象，那么它就和该对象对应的操作集合绑定了，比如当你创建字符串类型的对象时，你就可以针对这个对象进行字符串相关的操作

> Python是动态类型的(它会主动跟踪对象的实际类型)同时也是强类型(它只能进行适合该类型的操作)的

在功能上，表中列出的数据类型可能比你习惯使用的类型更常用也更强大，我们会在后面的学习中感受到这点

下面让我们快速浏览一下这些核心类型，后面我们会对每一种类型进行深入

# 数字

Python的数字类型包括整数和浮点数，除此之外还有其它的一些少见的类型如:有虚部的复数，固定精度的十进制数，带分子和分母的有理分数,集合等

Python的数字支持一般的数学运算，例如加号(+)代表加法，星号(*)表示乘法，双星号(**)表示乘方

``` python
>>> 123+222
345
>>> 1.5*4
6.0
>>> 2**100
1267650600228229401496703205376
```

注意最后一个结果，在Python3.0中，当数值较大时，它会自动提供额外的精度；在Python2.6中，它提供了长整型去处理这类大数值。

**有俩种打印对象的方式，一种对象的代码形式repr，一种是用户友好形式str**；当我们使用类时，这俩种的区别会展示出来。比如当我们在打印数字时，repr显示数字的全精度，而str显示对用户友好的形式

```python
>>> 3.1415 * 2
6.2830000000000004
>>> print(3.1415 * 2)
6.283
```
上面第一种是全精度形式。注意在实际测试中，第一行代码和第二行代码打印结果相同，应该是Python修复了精度的bug或者说计算这个数值时不存在精度的问题

除了表达式以外，Python还提供了**math**数学模块工具包,我们可以导入以使用它们

Python还包括了一些极为少见的数字对象，如复数，固定精度十进制数，有理数，集合和布尔值，第三方开源扩展领域还包括了其它更高级的如矩阵和向量。

# 字符串

字符串是用来记录文本信息的。严格意义上讲，字符串是的单个字符的字符串的序列。序列是一个包含其它对象的有序集合；序列中的元素包含了一个从左到右的顺序-序列中的元素根据它们的相对位置进行存储和读取，字符串是我们提到的第一个序列，其它序列还有列表和元组。

## 序列的操作

-- **所有序列共有的操作**

作为序列，字符串支持位置索引的相关操作；索引是按照从最前面的偏移量进行编码的，第一个的偏移量为0，第二个为1，以此类推。比如

```python
>>> S = 'Spam'
>>> len(S)
4
>>> S[0]
'S'
>>> S[1]
'p'
```

> len函数是Python中的内置函数，它将得到对象的长度

> 由S = 'Spam' 引申的变量赋值
>
>1. Python中的变量不需要提前声明，当给它赋值时就创建了它
>2. 当变量出现在一个表达式中时，就会用其值替换之前的值
>3. 在使用变量前必须对其赋值
> 
> 详细的变量规则将会在第六章给出

除此之外我们还可以使用反向索引；正向索引从左到右，反向索引从右到左

```
>>> S[-1]
'm'
```

一般来说，负索引会简单的与字符串的长度相加得出最终索引，如字符串长度为4时，当你取-1时，位置索引相加得3，那么它取得的就是第三个索引位置的值。如下，它们的结果是相同的

```python
>>> S[-1]
'm'
>>> S[len(S)-1]
'm'
```

在方括号中，Python支持我们使用数字常量，变量和表达式

除了位置索引，Python也支持分片操作；这使得我们可以一次性取得一个分片区域；它的语法为X[I:J]，表示**取出X中从偏移量I开始，直到J结束但不包括J**，结果将会返回一个**新的对象**，其中：**I默认为0，J默认为分片序列的长度**，并且它支持负索引，负索引的索引规则和上面相同。以下是分片的例子：

```python
>>> S[1:]  # J默认为S的长度
'pam'
>>> S      # S原序列并没有发生改变，分片操作会返回一个新的对象
'Spam'
>>> S[0:3]
'Spa'
>>> S[:3]   #I默认为0
'Spa'
>>> S[:-1]  #支持负索引
'Spa'
>>> S[:]   # 作用类似于拷贝一个新的序列对象
'Spam'
```

除此之外，序列还支持使用加号进行**合并**，或者**重复**

合并的语法为 var1 + var 2；它们会产生一个新的序列

重复的语法为 var1 * count；它会将var1重复count次

如下：

```python
>>> S
'Spam'
>>> S + 'xyz' # 合并的值可以是变量或常量或其它表达式
'Spamxyz'
>>> S * 3     # 将变量S的值重复三次
'SpamSpamSpam'
```

> 加号(+)对于不同的对象有不同的含义，这就是Python中的**多态**体现；它在这里是合并的意思，在数字中视为加法。简而言之，一个操作的意义取决于它所操作的对象。这种特性给Python的代码带来了极大的简洁性和灵活性。只要它们支持一种兼容的接口(就像这里的+)，Python的操作就可以自动的适应不同的对象。

## 不可变性

在之前的例子中，我们没有通过任何操作对原始的数据进行更改，修改的结果都作用在返回的对象中；这是因为在Python中，字符串具有**不可变性**，它在创建后就不可改变。我们不能通过对某一索引位置复制而改变它。但是我们可以通过新建一个字符串对象然后将值赋给原有变量的方式去改变变量的值，但是这仅仅是改变变量的值，它不会改变变量之前的字符量。如下：

```python
>>> S[0] = 'a'  # 当我们通过位置索引去复制时会发生错误
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> S = 'a' + S[1:]  # 我们可以通过对字符变量重新复制的方式改变它
>>> S
'apam'
```

> 在Python中，每一个对象都可以分为不可变性或可变性，在核心类型中，**数字**，**字符串**和**元组**是不可变的；**列表**和**字段**是可变的。

不可变性可以用来保证在程序中保持一个对象固定不变

## 类型特定的方法

-- 字符串类型的方法

字符串还有其独有的操作，它们作为方法存在

|字符串方法|含义|示例|结果|
|---|---|---|---|
|find|子字符串查找操作,它返回子字符串的位置偏移量，当没有找到时，返回-1|'Spam'.find(pa)|1|
|replace|替换子字符串|'Spam'.replace('pa','XYZ')|SXYZm|
|split|分割字符串|'a,b,c,d'.split(',')|['a','b','c','d']|
|upper|将小写字符转换为大写字母|'xY'.upper()|XY|
|isalpha|是否是字母|'a'.isalpha()|True|
|isdigit|是否是数字|'a'.isdigit()|Flase|
|rstrip|去除字符收尾空格字符|'aaa,bbb\n'.rstrip()|aaa,bbb|

注意虽然字符串方法名存在改变的含义，但是由于字符串是**不可变的**，所以它常常是返回一个新的字符串值，原来的字符串并不发生改变

除了这些基本的方法之外，字符串还支持一种叫做**格式化**的高级替换操作；它可以使用表达式的形式(最初的)或作为一个字符串方法(Python2.6和3.0新引入的)调用。

```python
>>> '%s 是 %s' % ('你','我的')
'你 是 我的'
>>> '{0} 也是 {1}'.format('你','我的')
'你 也是 我的'
```

> 通常来说；多种类型通用的操作都是以内置函数(len())或表达(S[0])式的形式出现，而类型特定的操作一般都是以方法调用的形式出现('a'.upper())。记住这些可以让我们很轻松的从Python世界中找到并使用我们需要的工具；下面会介绍一些技巧

## 寻求帮助

虽然我们在上面介绍了字符串的一些方法，但是对于字符串类型来说，这只是其中的一部分，我们可以通过以下的步骤去获取其它的方法列表和使用方式

1. 第一步，使用dir内置函数列出**对象**的属性，由于方法也是属性的一部分，所以它们也会被列出

    ```python
    >>> dir('a')
    ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '_
    _eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs
    __', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__'
    , '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',
    '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__'
    , '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'e
    ncode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isal
    num', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', '
    isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lo
    wer', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust',
    'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
    'swapcase', 'title', 'translate', 'upper', 'zfill']
    ```

    > 在后面我们会给出，我们可以通过自定义以下划线开头结尾的属性去定制自己的类型和操作
2. 第二步，使用help内置函数，获取对应属性的详细介绍

    ```python
    >>> help('a'.isupper)
    Help on built-in function isupper:

    isupper() method of builtins.str instance
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.

    ```

    help方法也支持传入一个对象，此时它将会返回对象所有方法的详细信息

    > Python中与help类似的有一个PyDoc工具，他可以从对象中提取文档，并将结果生成HTML格式

## 编写字符串的其它方法

* 反斜线转义序列表示的特殊字符

```python
>>> len('a\nB\tC') # \n代表换行 \t代表空格 它们每个代表一个字符
5
>>> ord('\n')      # \n 在ASCII中表示为10
10
>>> len('A\0B\0C') # \0 二进制0字节，不终止字符串
5
```

* 三引号包含多行字符；字符串可以包括在单引号和双引号中，它们的意义相同

```python
>>> a = '''
... a
... ccc
... '''
>>> a
'\na\nccc\n'
```
* 原始字符常量；对字符中的转义字符不做处理，它们通常以'r'开头
```python
>>> a = 'a\na'
>>> print(a)
a
a
>>> a = r'a\na'
>>> print(a)
a\na
```

* Unicode字符串

```python
>>> a = '\u6211'
>>> print(a)
我
```
> Python3.0中，str类型也处理Unicode，bytes类型表示原始字节字符串
> 
> Python2.6中，Unicode是单独的类型，str处理8位字符串和二进制数据 

## 模式匹配

使用模式匹配，我们需要导入**re**模块，然后使用它其中包含的工具方法

```python
>>> import re
>>> match = re.match('Hello[ \t]*(.*)world','Hello    Python world')
>>> match.group(1)
'Python '
>>> match = re.match('/(.*)/(.*)/(.*)','/usr/hoe/tesr')  # 当字符串为usr/hoe/tesr返回的match对象没有相关方法
>>> match.groups()
('usr','hoe','tesr')
```

模式匹配是一个相当高级的文本处理工具，在Python中，还支持更高级的语言处理工具，如**自然语言处理**等

# 列表

列表是一个**任意类型的对象**的**位置相关**的**有序**集合；它的大小是可变的，可以通过序列或列表相关的方法改变它自己。

## 序列操作

在字符串中介绍的序列相关的操作在这里都有效，只不过要注意，它返回的是列表而不是字符串

```python
>>> L = [1,'3',4,5.6]
>>> len(L)
4
>>> L[0]
1
>>> L[:-1]
[1, '3', 4]
>>> L + [5, 8]
[1, '3', 4, 5.6, 5, 8]
>>> L
[1, '3', 4, 5.6]
```

## 类型特定的操作

|字符串方法|含义|示例(以上面的L为例)|结果|
|---|---|---|---|
|append|在列表的尾部插入一条，扩充了列表的大小|L.append(7)|[1,'3'.4,5.6,7]|
|pop|移除给定偏移量的一项并返回偏移量位置的值，减少了列表的大小；也可以使用del语句|L.pop(0)|['3'.4,5.6,7]|
|sort|默认按照升序对列表进行排序,此时要求列表中的值是可比较的|||
|reverse|反转列表中的值；按照索引顺序反转，不要求列表中的值是可比较的|||

列表中的大多数方法都会直接对列表做出改变

## 边界检查

尽管列表没有固定的大小，但Python仍然不允许我们操作操作列表范围之外的值；比如索引超过列表大小之外外的值或对列表末尾之外的索引进行赋值。

Python不会让列表默默的增加它的大小，它会提示一个错误信息；为了让列表增大，我们可以使用append这样的方法

## 嵌套

Python**核心数据类型**的一个优秀的特性就是它们支持**任意的**嵌套；它们能够以任意的组合进行嵌套，并可以多个层次的嵌套；你可以在列表中包含字典，并且在字典中再包含列表。我们通过这样的特性可以实现更高级的数学模型，比如矩阵和多维数组

> 基于这种数据结果的矩阵效率并不是特别理想，可以使用凯元NumPy系统

## 列表解析

列表解析是一种通过对序列中的每一项运行一个表达式来创建一个新列表的方法。列表解析是写在方括号中的，这与列表的常量表达式类似

```python
>>> M = [[1,2,3],[4,5,6],[7,8,9]]
>>> clo2 = [row[1] for row in M]
>>> clo2
[2, 5, 8]
```

实际的列表解析语法比这要复杂一些，列表解析支持对每一次的索引值进行判断确定是否处理，可以对索引结果进行更加复杂的处理，并且它**可以解析任何可迭代的值**

列表解析在实际应用中比较方便，并且它具有处理速度上的优势

实际上，在Python3.0或最新的版本中，方括号中的解析语句还可以用于创建迭代器，集合，字典。我们会在后面学习到这些，在这里我们举一个生成迭代器的例子，引出list函数，他可以将可迭代对象解析成列表

```python
>>> [row for row in [1,2]]
[1, 2]
>>> list(row for row in [1,2,3])
[1, 2, 3]
```

> 我们可以理解方括号语法为list方法的语法糖，而列表解析表达式最核心的地方在于解析表达式本身，它不仅仅只运用在列表当中。在后面我们将看到，当表达式本身外括在字典或集合常量语法中时，它的结果将是一个字典或集合；当括在()中时，它的结果是一个迭代器。

# 字典

字典是一种**键值映射**；和序列一样，它也是一个**其他对象的集合**，但它又不同于序列，字典**使用键去索引值**而不是偏移量，它**没有严格的顺序**，只是简单的将键映射到值。同列表一样，它是**可变的**。

## 映射操作

字典的常量语法格式为

```
{键1:值1,键2:值2,键...:值...}
```

当我们需要把键与一系列值相关联的时候，它很有用。

我们可以通过键对字典进行索引从而读取/改变键关联的值；它的索引操作语法和序列的操作语法相同，只不过方括号中是键值而不是偏移量

```python
>>> D = {'food':'Spam','quantity':4, 'color':'pink'}
>>> D
{'food': 'Spam', 'quantity': 4, 'color': 'pink'}
>>> D['food']
'Spam'
>>> D['quantity'] += 1
>>> D
{'food': 'Spam', 'quantity': 5, 'color': 'pink'}
>>> E = {}
>>> E['name'] = 'Python'
>>> E
{'name': 'Python'}
```

除了使用键值之外，我们还可以使用键进行搜索操作；通过键索引一个字典是Python中编写搜索的最快方法。

## 重访嵌套

字典的值可以使任意数据类型的，它可以嵌入字典，列表，集合等其它数据类型，如下我们使用字典实现了一个简单的人员数据：

```python
>>> person = {'name':{'first':'wang','last':'tong'},'job':['dev','mgr'],'age':33}
>>> person['name']['first']
'wang'
>>> person['job'].append('it')
>>> person
{'name': {'first': 'wang', 'last': 'tong'}, 'job': ['dev', 'mgr', 'it'], 'age': 33}
```

我们可以看到，在Python中，创建一个这样的复杂数据结构是多么的简单和灵活；在C语言中，我们需要去创建一个结构体，并且它的结构是死板的不能变化的。

> 在Python中，我们也不需要再手动的去释放内存；它存在一种叫做**垃圾回收**的机制，当最后一次引用对象后，它所占用的内存空间会自动的被清理掉

## 键的排序：for循环

作为映射，字典仅支持通过键获取元素；然而在各种常见的特定场所，通过调用方法，它也支持类型特定的操作 

我们都知道，字典是无序存储的，当我们需要强调某种顺序时，我们应该如何去做的？

一种办法是，我们可以使用字典的keys方法收集到字典键的列表，然后对键的列表进行排序，之后循环排序后的键列表取出每个键对应的值

```python
>>> D= {1:2,3:1,2:4}
>>> D
{1: 2, 3: 1, 2: 4}
>>> Ks = list(D.keys())
>>> Ks
[1, 3, 2]
>>> Ks.sort()
>>> Ks
[1, 2, 3]
>>> for key in Ks:
...     print(key,'=>',D[key])
...
1 => 2
2 => 4
3 => 1
```

在最新的Python版本中，我们也可以使用sorted内置函数直接将字典的键值排序

```python
>>> D= {1:2,3:1,2:4}
>>> for key in sorted(D):
...   print(key,'=>',D[key])
...
1 => 2
2 => 4
3 => 1
```

> 在这里，我们看到了Python流程语句中的for循环语句，它用于遍历一个序列并且针对每一个序列值进行相似的操作，它类似于列表解析但不同于while，while用于重复执行一个操作但不仅仅是针对序列

## 迭代与优化

不管是for循环还是列表解析，它们的前提都是操作的对象遵守可迭代协议。

虽然for循环可以完成列表解析相同的工作，但是相较于列表解析和Python中其它相关的函数编程工具如map和filter，它的运行速度通常慢于它们

> Python中性能测试是一个很难应付的工作，因为在不同的版本中，它的优化程度不同。
> 
> Python对于性能优化的其中一条主要原则是(针对Python应用编码者)：首先为了简单和可读性去编写代码，在程序可以正常运行后，如果确实需要考虑性能问题再考虑它。一般情况下，这种情况下编写的代码已经够快了，当我们确实需要时，Python为我们提供了time，timeit模块和profile模块去完成性能上的调整

## 不存在的键：if测试

尽管我们可以通过给新键赋值来扩展字典，但当我们获取不存在的键时，它仍会报错--获取一个不存在的东西往往是一个程序错误

但是在实际工作中，我们并不能保证我们访问的键就真的存在，此时我们应该怎么做呢？

我们可以首先通过**in**语句去测试字典中是否存在某键，然后再使用if条件分支语句去做处理

```python
>>> D= {1:2,3:1,2:4}
>>> 4 in D
False
>>> if not 4 in D:
...     print('miss key 4')
...
miss key 4
```

> 简单来说，if语句接受一个结果为真或为假表达式，根据表达式的结果去执行相应的语句，它一般和else/else if 分句一块使用

除此在外，我们还有其它方式去获取可能为空的键值

* get方法：它带有一个默认值参数，当所指的键不存在时，会返回给定的默认值

```
>>> D.get(4,5)
5
```

* Python2.X的has_key方法；Python3.0中不可用

* try语句；当获取值异常时刻捕获该异常进一步处理

* if/else表达式(挤在一行的if语句)

```python
>>> D[4] if 4 in D else 5
5
```

# 元组

元组基本上就像一个**不可改变**的列表，它也是**序列**，支持任意类型，任意嵌套和常见的序列操作；它被括在小括号中：

```python
>>> T = (1,2,3,4)
>>> T
(1, 2, 3, 4)
>>> T + (5,6)
(1, 2, 3, 4, 5, 6)
>>> T[0]
1
>>>
```

在Python中，它有俩个专有的方法 

```python
>>> T.index(4)   # 指定元素出现在元素中的偏移位置
3
>>> T.count(4)   # 指定元素的个数
1 
>>> T.index(6)   # 元组中无数据时会报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: tuple.index(x): x not in tuple
```

## 为什么要用元组

由于元组是不可变的，它可以保证数据在全局的完整性；不像列表，可能在程序中的某一位置发生不可察觉的变化

# 文件

文件对象是对电脑上外部文件操作的主要接口，它虽然是核心类型，但它并**没有特定的常量语法**；要创建一个文件对象，只需要调用open内置函数，它接受一个文件的地址和一个处理模式；如下创建一个文本输出模式的文件，'w'模式代表写入模式

```python
>>> f = open('data.txt','w')
>>> f.write('hello word')
10
>>> f.close()
```

> 当文件为相对路径时它的位置在当前位置相对的路径，比如上面，它会在当前目录下生成一个文件；当文件为绝对路径时它会在指定的目录下生成文件

我们可以使用'r'模式读取文件，当我们没有指定处理模式时，默认及时'r'模式

```python
>>> f = open('data.txt')
>>> t = f.read()
>>> t
'hello word'
>>> f.close()
```

对脚本而言，文件的内容总是字符串，不管它的实际内容是什么类型

文件还包括其它方法我们会在后面给出；如读取字节大小的read方法，读取一行的readline方法和移动到给定位置的seek方法。文件也提供了迭代器使我们可以一行行的读取文件。后面还会看到Python3.0中文件对象是如何处理文本文件和二进制文件的，简单来说文本文件被Unicode编解码，而二进制文件被处理为字节字符串类型。

## 其它文件类工具
除了open这种方式外，Python还提供了其它的类文件工具，如管道，先进先出队列，套接字(网络和进程间通信)，通过键访问文件，对象持久，基于描述符的文件(文件锁定和其它的底层工具)，关系型数据库和面向对象数据库接口等

# 其它核心类型

除了以上那些，还有一些**或许可以**被称为核心类型的类型：

## 集合
 集合是唯一的不可变的对象的无序集合，它是最近新增到Python中的，它不是映射也不是序列；我们可以通过set内置方法或常量表达式{...}，从语法上看它更像是一个无值的字典的键；集合支持一般的数学操作

```python
>>> a = {1,1,2,3}    # 不可重复的
>>> a
{1, 2, 3}
>>> b = {3,4,5}
>>> b
{3, 4, 5}
>>> a & b            # 交集    
{3}
>>> a | b            # 并集
{1, 2, 3, 4, 5}
>>> a - b            # 差集
{1, 2}
>>> a                # 原集合不变
{1, 2, 3}
```

> set,map,list这样的内置方法内接受迭代器为参数，并且将迭代器分解为相应的值类型

## 十进制数和分数

十进制数(decimal：固定精度浮点数)和分数(fractions：表示分子和分母的有理数)用来解决浮点数的局限性和不精确性

```python
>>> 1/3
0.3333333333333333
>>> (2/3)+(1/2)
1.1666666666666665
>>> import decimal                  # 十进制数
>>> d = decimal.Decimal('3.141')
>>> d+1
Decimal('4.141')
>>> decimal.getcontext().prec = 2   # 设置精度为2
>>> decimal.Decimal('1.00')/decimal.Decimal('3.00')
Decimal('0.33')
>>> from fractions import Fraction  # 分数
>>> f = Fraction(2,3)               # 表示2/3
>>> f+1
Fraction(5, 3)
>>> f + Fraction(1,2)
Fraction(7, 6)
```

## 布尔值

预定义的True和False对象实际上是定制后以逻辑结果显示的1和0

```python
>>> 1>2,1<2
(False, True)
>>> bool('spam')
True
```

## 特殊占位符None

通常用于初始化名字和对象

```python
>>> X = None
>>> print(X)
None
>>> L = [None]*10
>>> L
[None, None, None, None, None, None, None, None, None, None]
```

## 如何破坏代码的灵活性

内置函数type会返回给定对象额类型，首先我们需要注意，type在Python2.6和Python3.0中的不同

```python
# in 2.6
>>> type(L)    # L为上面示例的L
<type 'list'>
>>> type(type(L))
<type 'type'>
# in 3.0
>>> type(L)
<class 'list'>
>>> type(type(L))
<class 'type'>
```

可以看出Python3.0中它和**类**结合起来了

我们可以使用type内置函数去校验要操作的对象类型，并执行相应的操作

```python
>>> if type(L) == type([]):
...     print('list')
...
list
>>> if type(L) == list:
...     print('list')
...
list
>>> if isinstance(L, list):
...     print('list')
...
list
```

但是Python并不建议这样使用它，这会破坏Python的灵活性，这限制了它只能在一种类型中工作；实际上Python有一个**多态**的概念，它允许我们面向接口开发，当我们的操作适配于这个接口时它就是可用的，它不会管你实际是什么类型

## 用户定义的类

这是一种面向对象的编程模式，在Python中，它是可选的，但是它是一个很强大的特性；我们可以通过编写自己的类去**扩展核心类型**

类也可以看做是核心类型的组合，它是建立在核心类型之上的；这里记住一个原则，能使用核心类型的就不要自定义类

更多关于类的详细信息，我们在后面章节给出

## 剩余的内容 

就像之前说的，Python脚本中能够处理的所有事物都是某种类型的对象，上面介绍的仅仅是Python核心类型集合中的一部分，其它的类型介绍我们会在后面学习

我们上面所列出的对象仅仅是对象，并不一定是面向对象，面向对象一般要求有继承和Python类声明的概念。Python和核心类型往往是更多非核心类型的基础

# 最后

> 序列是一个对位置进行排序的对象的集合

> 映射表示将键与相关值相互关联映射的对象

> 多态的意义在于它所进行的操作取决于操作的对象
