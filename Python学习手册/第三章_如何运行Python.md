# 交互提示模式下编写代码

最简单的运行Python的方式就是在Python交互命令行中输入这些程序，可以在系统终端，IDE中打开命令行。你只需要在命令行中输入Python命令：

* 在Windows中，你可以在DOS终端窗口中输入或者在运行的对话框(WIN+R组合键打开)中
* 在Unix，Linux，MAC OS中，你可以在shell窗口或终端窗口中
* 在其他的平台或系统你可以使用特定于平台的方式

> 注意:如果你没有在系统环境变量中设置Python的安装目录，那么你需要在Python命令前加上其完整路径，或者将系统位置定位到Python的安装目录下。

> 在Windows中，你也可以通过启动程序目录中的IDLE主窗口或者打开Python程序的方式打开交互模式<br/>
> ![import this](static/img/3_1_启用Python命令行.png)

## 交互地运行代码

通过上面的方式打开交互模式后，会出现像下图这样的窗口(以下是在Windows中启动IDLE主窗口的方式打开的)：
![import this](static/img/3_2_PythonIDLE命令行.png)

你可以在">>>"后面编写Python语句，它会在你敲打回车键之后立即执行并在下一行打印出执行结果。

> 在命令行模式中，它会自动打印输入表达式的结果，因此你不必刻意的去输入**print**打印结果

> 输入多行表达式时，通过敲打两次回车键后执行结果，稍后会讲到

在这之后，在Unix系统中你可以通过键入Ctrl+D组合键来退出命令行或者在MS-DOS，Windows中键入Ctrl+Z，在IDLE窗口中你可以键入Ctrl+D或关闭窗口退出

> 注意：Windows命令行中Ctrl+Z亲测不能使用，可以选择关闭对话框或使用exit()函数退出

## 为什么使用交互提示模式

* 实验：由于它是立即执行的，所以当你看到不理解的语句时，可以直接在交互模式下输入语句来查看结果，这是搞清楚一段代码究竟做什么的最快的方式
* 测试：可以通过导入模块来快速测试模块的正确性，也可输入命令来连接C函数，java类等

## 使用交互提示模式
下面是使用过程中注意的一些细节：
* 只能够输入Python命令
* 在py文件中，只有输入**print**后才会打印结果，在交互提示模式下可以不输入
* 语句开头不要出现缩进字符。这在单个简单语句中适用，如果是多行复合语句，则需要缩进保持语法正确性
* 留意提示符的变化，正常情况下提示符是>>>，在多行复合语句中，它会是...或者缩进行。
    > Ctrl+C组合键可以返回主提示模式
* 用空行结束复合语句，单个简单语句回车就可以执行，复合语句则需要两次回车至出现一个空行才可以执行
* 一次只能执行一条语句

### 输入多行语句
以下是运行多行语句的示例，可以看到行首是以...开头，并且以空行结尾
![import this](static/img/3_3_命令行运行复合语句.png)

这里需要注意的是，空行结尾只有在交互提示模式下是必须的，在编写脚本时，空行将会被省略，另外交互提示模式下一次只能运行一条语句，所以在复制粘贴代码时要注意不能粘贴多行代码，除非这些代码的每条复合语句后面都有空行。多行代码一般是写在一个文件中。

# 系统命令行和文件

尽管交互式命令行对于**实验和测试**来说都很好，但是它有一个很大的缺点：**执行之后就消失了**。复制粘贴也只能起到一点微弱的作用，特别是在稍大的程序中，它需要我们清理提示符，输出和其它的东西，这不是一种现代的软件开发方法。

为了使程序可以永久保存，我们需要在文件中写入代码；这样的文件我们成为**模块**。模块是一个包含了Python语句的**简单文本文件**。Python解释器可以多次运行这样的文件，你可以通过系统命令行，点击图标，IDLE等多种方式去运行它，它每次运行时都会从头至尾的执行模块文件中的每一条代码。

> **模块文件**这个术语可能在某些地方会有不同。一般来说包含一系列Python语句的可执行程序文件我们称之为**模块文件**。但是有时我们将可直接运行的模块文件称为**脚本**。也有人将被其它的文件引入的文件称为**模块**。

下面几部分内容，我们将介绍如何运行模块文件。首先我们来看一个简单粗糙但实用的方法：在系统提示模式下运行：

```
> python 模块文件名.py
```

## 第一段脚本

让我们打开任意文本编辑器，输入一下代码，并将其保存为[script1.py](code/03/script1.py)
```python
# 导入python模块，以获取系统平台名称
# #号之后为注释内容，不会被当做语句去执行，它可以使单独一行也可以在语句后
import sys
# 调用print函数，显示脚本的结果
# 当前平台的名称
print(sys.platform)
# 2的100次方
print(2 ** 100)
# 声明一个变量，在创建时为其赋值，保存一个字符串变量
x = 'spam!'
# 字符串重复
print(x * 8)
```

> 对于**顶层文件**而言，我们可以称它为**脚本**。

> 这里文件的.py后缀不是必须的，但是导入的模块文件必须是.py结尾的；而且.py后缀的文件会被文本编辑器识别从而帮助我们更好的编程，它会提供语法高亮和自动缩进等功能。

## 使用命令行运行文件
我们可以通过输入以下命令在模块文件所在的位置运行python命令，以下是命令和其输出

```
D:\github\book-notes\Python学习手册\code>python script1.py
win32
1267650600228229401496703205376
spam!spam!spam!spam!spam!spam!spam!spam!
```
我们也可以将语句保存在[非.py后缀文件](code/03/script1.txt)中；运行结果同上
```
D:\github\book-notes\Python学习手册\code>python script1.txt
win32
1267650600228229401496703205376
spam!spam!spam!spam!spam!spam!spam!spam!
```
> 如果你没有将python设置到环境变量中，那么我们需要用完整的目录路径去替换python命令

> 如果模块文件不在当前执行目录中，则需要给出模块文件的完整路径

由于这种方法是使用shell命令进行启动，所以常见的shell语法在这也适用；如下我们使用**流重定向**，将输出输出到[文件](/code/03/script1_output.txt)中。

```
D:\github\book-notes\Python学习手册\code>python script1.py > script1_output.txt
```

在最新的window平台中，由于系统本身会在注册表中查找执行文件的程序，所以我们可以省略掉python命令;此时我们必须指定文件后缀名为.py(windows本身通过后缀名去匹配执行程序)：

```
D:\github\book-notes\Python学习手册\code>script1.py
win32
1267650600228229401496703205376
spam!spam!spam!spam!spam!spam!spam!spam!
```

## 使用命令行和文件

在使用命令行运行文件时，需要注意一下几点陷阱：

* 注意windows上的文件扩展名；当系统隐藏扩展名时，我们需要更加小心；word文件会增加Python中不合法的格式字符。我们可以选择使用更加友好的文本编辑器，比如IDLE，它不会添加文件后缀。

* 在系统提示模式下需要指定模块文件的完整文件名，而在导入时只需要模块名；这是因为在系统提示下，使用的是系统的文件搜索规则，而在导入时，使用的是Python的模块文件搜索规则。

* 在文件中使用print语句(函数);在交互模式下，Python会自动响应表达式的结果，在这里不会。

## UNIX可执行脚本(#!)

我们可以在liunx这样的类UNIX系统上编写Python的可执行脚本；它们和windows上的文本文件的编写方式相同，但是有两个特殊的属性

1. 首行以#!开始，后跟Python解释器的路径
2. 需要将文件权限设置为可执行文件；可以使用chmod +x 文件名方式设置

> 这这里，顶层文件可以不用指定.py后缀名

编写完毕后，我们可以直接指定文件名去运行它；比如我们新建了一个名为brian的Python文件

```
#!/usr/local/bin/python
print('hello world')
```

我们可以直接使用下列的命令运行它

```
% brian
```
> 注意，当文件不在环境变量中时，应指定文件的完整路径

我们可以使用这种方式在类NUIX系统上运行它，但一般情况下为了平台的通用性，我们使用**python 文件名**这样的方式运行它会使我们的生活变得简单，此时，我们无需指定行首也无需去指定文件的可执行权限

我们也可以使用类UNIX的env去查找python解释器的位置，比如
```
#!/usr/bin/env python
# Python代码
```
此时env程序会自动去查找Python解释器的位置，无需我们硬编码去指定它；这可以在类UNIX系统上获得较高的通用性，但是这需要env程序在我们指定的路径下。

> env程序会在环境变量下去寻找Python解释器，所以这需要你将Python解释器添加到环境变量中

# 点击文件图标

在windows系统中，注册表可以帮助我们实现双击Python模块文件文件就可以运行一个Python程序；注册表会自动查找运行该文件的程序。

在其他系统中，我们也可以通过如关联文件的MIME类型这样的方式实现这一点，具体可以参考各个系统文件管理器的文档

## 在Windows中点击图标

还是以上面的[script1.py](code/03/script1.py)为例，我们打开我的电脑，点击定位到文件的位置，然后鼠标双击就可以了。

通常我们会双击.py文件，这是**源码文件**，这会使我们得到修改后的最新结果，我们也可以点击.pyc文件，这是**字节码文件**

## input的技巧

我们通过双击可以看到，屏幕总是一闪而过，这是一个正确的结果，程序会打开一个dos终端窗口运行，运行完了之后关闭它；但是这显然不是我们想要的结果。

我们可以通过在脚本最后添加input(Python2.6中为raw_input)内置函数让它在运行完程序之后"暂停"一下,如下：
```python
import sys
print(sys.platform)
print(2 ** 100)
x = 'spam!'
print(x * 8)
input()
```
这是因为iput函数实际上是读取标准输入流的函数，在这里当你没有输入任何内容时，它会等待直至你输入内容并敲下回车或者直接敲回车为止，感觉上像是程序"暂停"了一样

这个技巧只有当在windows中，程序输出即退出，点击图标运行这三个条件全部满足时才使用；请注意，input函数的实际含义是接受用户的输入。

我们也可以这样使用imput函数：

* 键入提示语句：input('请按下Enter键退出')
* 接受输入的内容：inputStr = input();
* shell时，像前面的输出重定向一样，可以使用输入重定向：python spam.py < input.txt

在后面章节中，我们会更详细的介绍input的用法

> 版本差异
> 
> 注意在Python2.6中，等价函数为raw_input函数，2.6中也有input函数，但它会将输入当做表达式去求值，然后将求值的结果返回给接受变量；在python3.0中我们可以使用eval(input())实现这一点，eval函数会去执行某一段字符。




